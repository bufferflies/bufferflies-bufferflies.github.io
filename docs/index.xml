<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jane - A super concise theme for Hugo</title>
    <link>https://bufferflies.github.io/</link>
    <description>Recent content on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 28 Sep 2014 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://bufferflies.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>简介</title>
      <link>https://bufferflies.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://bufferflies.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>webflux源码设计1</title>
      <link>https://bufferflies.github.io/post/webflux%E8%A7%A3%E6%9E%901/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://bufferflies.github.io/post/webflux%E8%A7%A3%E6%9E%901/</guid>
      
        <description>&lt;h1 id=&#34;spring5-webflux-源码解析一&#34;&gt;Spring5 WebFlux 源码解析（一）&lt;/h1&gt;
&lt;h2 id=&#34;场景&#34;&gt;场景：&lt;/h2&gt;
&lt;p&gt;能够将&lt;strong&gt;请求&lt;/strong&gt;适配到&lt;strong&gt;指定方法&lt;/strong&gt;，&lt;strong&gt;调用&lt;/strong&gt;方法并&lt;strong&gt;返回&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;领域图&#34;&gt;领域图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-plantuml&#34; data-lang=&#34;plantuml&#34;&gt;storage Request as W
storage HandlerMapping as M
storage HandlerAdapter as A
storage HandlerResultHandler as R
entity Result as E
control Handler as C

W -&amp;gt; M: trigger
M -&amp;gt; C: find 
E -&amp;gt; R: consume 
C -&amp;gt; A: adapt
A -&amp;gt; E: transfer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对象解释
Request: 代表用户的请求
HandlerMapping： 处理器寻找器 根据请求参数，寻找到处理器
HandlerAdapter： 处理器适配器（入参和出参适配）
HandlerResultHandler：结果处理器
Result： 处理器处理后的结果
Handler： 处理器（需要用户编写）&lt;/p&gt;
&lt;h2 id=&#34;类图&#34;&gt;类图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-plantuml&#34; data-lang=&#34;plantuml&#34;&gt;interface HandlerMapping{
    getHandler(ServerWebExchange ex):Object
}
interface HandlerAdapter{
    supports(Object object):boolean
    handler(ServerWebExchange ex, object):HandlerResult
}
interface HandlerResultHandler{
    supports(HandlerResult result): boolean 
    handle(ServerWebExchange ex, HandlerResult result): void
}
class HandlerResult{
    Object handler
    Object returnType
    Object returnValue
    Object returnBingContext
    Function&amp;lt;Throwable, HandleResult&amp;gt; exceptionException
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;时序图&#34;&gt;时序图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-plantuml&#34; data-lang=&#34;plantuml&#34;&gt;actor User as U
boundary DispatcherHandler as D
control HandlerMapping as M
control HandlerAdapter as A
control HandlerResultHandler as R

U -&amp;gt; D: send Request
D -&amp;gt; M: find a handler that can resolve the request
M --&amp;gt; D: return Handler
D -&amp;gt; A: process the handler
A --&amp;gt; D: return HandlerResult
D -&amp;gt; R: process result 
R --&amp;gt; D: return response 
D --&amp;gt; U: render  
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;核心链式调用&#34;&gt;核心链式调用：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-plantuml&#34; data-lang=&#34;plantuml&#34;&gt;(*) --&amp;gt; [request] &amp;quot;HandlerMapping&amp;quot;
--&amp;gt;[Handler] &amp;quot;HandlerAdapter&amp;quot;
--&amp;gt;[Adapt] &amp;quot;HandlerResult&amp;quot;
--&amp;gt;[Response] &amp;quot;Socket&amp;quot;
--&amp;gt;(*)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;附录&#34;&gt;附录&lt;/h3&gt;
&lt;h4 id=&#34;附录一&#34;&gt;附录一&lt;/h4&gt;
&lt;p&gt;spring 最核心代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	public Mono&amp;lt;Void&amp;gt; handle(ServerWebExchange exchange) {
		if (this.handlerMappings == null) {
			return createNotFoundError();
		}
		// 找到所有注册的Mappings
		return Flux.fromIterable(this.handlerMappings)
				// 按序寻找可以处理该请求的Mapping
				.concatMap(mapping -&amp;gt; mapping.getHandler(exchange))
				// 只返回一个
				.next()
				//无法进行处理 抛出404异常
				.switchIfEmpty(createNotFoundError())
				// 寻找最适合的适配器并执行Handler 返回结果
				.flatMap(handler -&amp;gt; invokeHandler(exchange, handler))
				// 寻找结果处理器， 写回到Response中
				.flatMap(result -&amp;gt; handleResult(exchange, result));
	}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;核心类单元测试构造&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;映射处理器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// mock 一个HandlerMapping 接口 并使其继承Ordered 接口
HandlerMapping hm1 = mock(HandlerMapping.class, withSettings().extraInterfaces(Ordered.class));
// 实现Ordered接口
given(((Ordered) hm1).getOrder()).willReturn(1);
// 给定任何参数返回“1”
given((hm1).getHandler(any())).willReturn(Mono.just((Supplier&amp;lt;String&amp;gt;) () -&amp;gt; &amp;quot;1&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;适配器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
private static class SupplierHandlerAdapter implements HandlerAdapter {

   // 支持所有的Supplier类型的处理器
       @Override
       public boolean supports(Object handler) {
           return handler instanceof Supplier;
       }
  // 执行处理器 将其结果转换为HandlerResult
       @Override
       public Mono&amp;lt;HandlerResult&amp;gt; handle(ServerWebExchange exchange, Object handler) {
           return Mono.just(new HandlerResult(handler, ((Supplier&amp;lt;?&amp;gt;) handler).get(), RETURN_TYPE));
       }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;结果处理器&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;private static class StringHandlerResultHandler implements HandlerResultHandler {

       @Override
       public boolean supports(HandlerResult result) {
           Object value = result.getReturnValue();
           return value != null &amp;amp;&amp;amp; String.class.equals(value.getClass());
       }

       @Override
       public Mono&amp;lt;Void&amp;gt; handleResult(ServerWebExchange exchange, HandlerResult result) {
       // 获取response中的值
           byte[] bytes = ((String) result.getReturnValue()).getBytes(StandardCharsets.UTF_8);
           // 将其转换为DataBuffer类型
           DataBuffer dataBuffer = new DefaultDataBufferFactory().wrap(bytes);
           // 填充到response中
           return exchange.getResponse().writeWith(Mono.just(dataBuffer));
       }
   }
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>webflux源码设计2</title>
      <link>https://bufferflies.github.io/post/webflux%E8%A7%A3%E6%9E%902/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://bufferflies.github.io/post/webflux%E8%A7%A3%E6%9E%902/</guid>
      
        <description>&lt;h2 id=&#34;核心类图&#34;&gt;核心类图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-plantuml&#34; data-lang=&#34;plantuml&#34;&gt;class RouterFunction {
  RouteFunction routeFunction; 路由执行器
  List&amp;lt;HttpMessageReader&amp;lt;?&amp;gt;&amp;gt; messageReaders; request阅读器
  getHandlerInternal(ServerWebExchange ex): HandlerFunction 获取对应的执行器
}

class HandlerFunctionAdapter {
  supports(Object handler): boolean 只支持HandlerFunction 的函数
  handler(ServerWebExchange ex,Object handler): HandlerResult 执行方法并进行的转换
}

class ServerResponseResultHandler {
    List&amp;lt;HttpMessageWriter&amp;lt;?&amp;gt;&amp;gt; messageWriters: response 编写器
    List&amp;lt;ViewResolver&amp;gt; viewResolvers： 视图映射
    supports(HandlerResult result)：boolean 只处理返回类型为ServerResponse类型
    handleResult(ServerWebExchange exchange,HandlerResult result): void 将结果写入到response中
    
}

interface HandlerFunction{
   handle(ServerRequest request): T 最直接的操作 业户逻辑入口 一般lambda实现
}

interface RequestPredicate{
    test(ServerRequest request): boolean
}

interface RouteFunction {
  route(ServerRequest request): HandlerFunction 该路由是否能够满足该请求 核心
  and(RouteFunction other):  SameComposedRouterFunction 合并
  andOther(RouteFunction other): DifferentComposedRouterFunction 合并
  andRoute(RequestPredicate predicate, HandlerFunction&amp;lt;T&amp;gt; handlerFunction): RouterFunction 比较底层
  andNest(RequestPredicate predicate, RouterFunction&amp;lt;T&amp;gt;  routerFunction): RouterFunction 合并路由
  filter(HandlerFilterFunction&amp;lt;T, S&amp;gt; filterFunction): 带有过滤的路由
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RouteFunction 会将所有的RouteFunction进行聚合&lt;/li&gt;
&lt;li&gt;过滤其实是在mapping的时候执行的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;初始化过滤：&lt;/p&gt;
&lt;h2 id=&#34;时序图&#34;&gt;时序图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-plantuml&#34; data-lang=&#34;plantuml&#34;&gt;actor Processor as U
control RouteFunction as R
control Predicate as P 
control HandlerFunctionAdapter as A
control ServerResponseResultHandler as R

U -&amp;gt; R : getHandler
R -&amp;gt; P : test the request
P --&amp;gt;R : OK
R --&amp;gt;U : return HandlerFunction
U -&amp;gt; A : execute the handler
A --&amp;gt;U : return and wrap to HandlerResult
U -&amp;gt; R: test
R -&amp;gt;U : write value to response  
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>
